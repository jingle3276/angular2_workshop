<!DOCTYPE html>
<!-- saved from url=(0050)http://angulartestingquickstart.com/#testing-route -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\:form{display:block;}</style>
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>Angular Unit Testing</title>

  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="./Angular Unit Testing_files/bootstrap.min.css">

  <!-- Optional theme -->
  <link href="./Angular Unit Testing_files/css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="./Angular Unit Testing_files/bootstrap-theme.min.css">
  <link rel="stylesheet" href="./Angular Unit Testing_files/zenburn.min.css">
  <link rel="stylesheet" href="./Angular Unit Testing_files/core.css">
  <link rel="stylesheet" href="./Angular Unit Testing_files/ui-changes.css">
  <link rel="icon" href="http://angulartestingquickstart.com/favicon.ico?v=1">

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body ng-app="Quickstart" data-spy="scroll" data-target="#table-of-contents" id="top" class="ng-scope">
  <div class="col-sm-12 no-padding-h">
    <nav id="table-of-contents" class="affix" style="max-height: 897px;">
      <ul class="nav">
        <li class=""><a href="http://angulartestingquickstart.com/#sample-project">Where can I see the actual tests?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#unit-testing">How does Karma differ from Protractor?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#installing-karma">How do I install Karma?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#configuring-karma">How do does Karma know which files to include?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#basic-jasmine">How is a basic spec organized?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#including-module">How do I inject a module in a spec?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#testing-controller">How do I instantiate a controller in a spec?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#including-service">How do I inject a service in a spec?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#testing-template">How do I test if an element is in the DOM?</a></li>
        <li class="active"><a href="http://angulartestingquickstart.com/#testing-route">How do I test route changes?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#testing-directive">How do I set up a spec for a directive?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#mocking">How/Why do I mock a service call in a controller spec?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#spying-methods">How do I determine if one method successfully calls another method?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#spying-methods">How do I determine what arguments were included when I call a method?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#testing-promise">How do I handle async operations in a spec?</a></li>
        <li><a href="http://angulartestingquickstart.com/#debugging">How do I troubleshoot problems with my specs?</a></li>
        <li><a href="http://angulartestingquickstart.com/#best-practices">How do I know I am formatting my specs in the most efficient manner?</a></li>
        <li class=""><a href="http://angulartestingquickstart.com/#resources">Resources</a></li>
      </ul>
    </nav>
  </div>
  <div class="container-fluid" id="top">
    <div class="row">
      <div class="col-sm-12">

        <div class="main-content">
          <img class="pull-right" src="./Angular Unit Testing_files/testing-quickstart.png" alt="Testing Quickstart" width="200">

          <h1>Angular Unit Testing Quick Start</h1>
          <h3 class="section-heading" id="sample-project">Introduction</h3>
          <p class="section-question">Why are you doing this?</p>
          <p>Angular was written from the ground up to be testable and yet there are scores of Angular developers who are not writing enough (if any) tests for their application. Why is this? I believe that it is because that while testing Angular is easy,
            actually getting to that first step is hard. I remember the feeling of despair I felt the first time I was tasked with writing tests for a project I was on. Where do I start? How do I get this Karma thing to actually run? Find my files? How
            do I instantiate my controller? What if it has a service dependency? Aaaaaaaaargh!</p>
          <p>I have since covered a lot of ground over the last couple years and I found that once you understand a few basic rules of engagement that testing in Angular is actually pretty straight forward and formulaic.</p>
          <p>I wanted to try to illustrate some of these basic patterns in an easy to read, approachable way so that developers can get to that first test without losing their mind</p>
          <p>Please use this material as a bridge to making tests a natural part of your development process; and if you find something amiss, do not hesitate to create a pull request on the
            <a href="https://github.com/simpulton/angular-testing-quick-start-guide">repo</a>. Nothing would make me happier! Enjoy!</p>

          <h3 class="section-heading" id="sample-project">The Sample Project</h3>
          <p class="section-question">Where can I see the actual tests?</p>
          <p>The companion repository for this quick start guide can be found here <a href="https://github.com/simpulton/angular-testing-quick-start">https://github.com/simpulton/angular-testing-quick-start</a></p>

          <h3 class="section-heading" id="unit-testing">Unit Testing vs E2E</h3>
          <p class="section-question">How does Karma differ from Protractor?</p>

          <p>I like to split my tests up into three different categories:</p>

          <ol>
            <li>
              <strong>End-to-End Tests</strong> - These are the tests where you want to mimic an actual user that visits your website. Each test contains a series of simulated user events (ex. go to http://mysite.com/home and then click on the button with ID
              'my-button') and expected results (ex. after 200ms a new window should appear that says "Thank You").</li>
            <li>
              <strong>Integration Tests</strong> - These tests will call directly into your code. For example, you can use an integration test to call an Angular service. Typically each test will focus on one function. The test calls the target function with
              a set of parameters and then checks to make sure the results match expected values.</li>
            <li>
              <strong>Unit Tests</strong> - These are the same as integration tests except you take extra steps toensure that nothing is executed besides the one function you are testing. For example, when you test a service that uses $http to call a back end
              API, an integration test would include the API call. A unit test, however, would use a utility we will discuss later called $httpBackend to replace $http so that the code executed by the test is restricted to just the target function.</li>
          </ol>

          <p>Protractor is the tool you will use for end-to-end tests while Karma handles integration and unit testing.</p>

          <h3 class="section-heading" id="installing-karma">Installing Karma</h3>
          <p class="section-question">How do I install Karma?</p>
          <pre>            <code class="js hljs javascript">npm install -g karma</code>
          </pre>


          <h3 class="section-heading" id="configuring-karma">Configuring Karma</h3>
          <p class="section-question">How do does Karma know which files to include?</p>
          <pre>            <code class="js hljs javascript">karma init karma.conf.js</code>
          </pre>

          <p>After installing Karma, we need to set up the karma.conf file. The files array in karma.conf contains all the files needed to run a test. This includes:</p>

          <ul>
            <li>Any angular libraries used by your code</li>
            <li>All your custom code</li>
            <li>All your test specs</li>
          </ul>

          <p>Below is an example of a full karma.conf file.</p>


          <pre>            <!-- ngInclude: 'templates/karma-config.tpl.js' --><code ng-include="&#39;templates/karma-config.tpl.js&#39;" class="js ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(config)</span> </span>{
    config.set({

        <span class="hljs-comment">// base path that will be used to resolve all patterns (eg. files, exclude)</span>
        basePath: <span class="hljs-string">''</span>,


        <span class="hljs-comment">// frameworks to use</span>
        <span class="hljs-comment">// available frameworks: https://npmjs.org/browse/keyword/karma-adapter</span>
        frameworks: [<span class="hljs-string">'jasmine'</span>],


        <span class="hljs-comment">// list of files / patterns to load in the browser</span>
        files: [
            <span class="hljs-string">'src/vendor/angular.min.js'</span>,
            <span class="hljs-string">'src/vendor/angular-mocks.js'</span>,
            <span class="hljs-string">'src/vendor/angular-ui-router.min.js'</span>,
            <span class="hljs-string">'src/assets/js/unit-test-helpers.js'</span>,
            <span class="hljs-string">'src/app/**/*.html'</span>,
            <span class="hljs-string">'src/app/**/*.spec.js'</span>,
            <span class="hljs-string">'src/app/**/*.js'</span>
        ],


        <span class="hljs-comment">/*********************************************************/</span>
        <span class="hljs-comment">// Note: this was added AFTER karma init was completed.</span>
        <span class="hljs-comment">/*********************************************************/</span>
        ngHtml2JsPreprocessor: {
            stripPrefix: <span class="hljs-string">'src/'</span>,
            <span class="hljs-comment">//stripSufix: '.ext',</span>

            <span class="hljs-comment">// setting this option will create only a single module that contains templates</span>
            <span class="hljs-comment">// from all the files, so you can load them all with module('foo')</span>
            moduleName: <span class="hljs-string">'myAppTemplates'</span>
        },

        <span class="hljs-comment">// list of files to exclude</span>
        exclude: [],


        <span class="hljs-comment">// preprocess matching files before serving them to the browser</span>
        <span class="hljs-comment">// available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor</span>
        preprocessors: {
            <span class="hljs-string">'src/app/**/*.html'</span>: [<span class="hljs-string">'ng-html2js'</span>]
        },


        <span class="hljs-comment">// test results reporter to use</span>
        <span class="hljs-comment">// possible values: 'dots', 'progress'</span>
        <span class="hljs-comment">// available reporters: https://npmjs.org/browse/keyword/karma-reporter</span>
        reporters: [<span class="hljs-string">'progress'</span>],


        <span class="hljs-comment">// web server port</span>
        port: <span class="hljs-number">9876</span>,


        <span class="hljs-comment">// enable / disable colors in the output (reporters and logs)</span>
        colors: <span class="hljs-literal">true</span>,


        <span class="hljs-comment">// level of logging</span>
        <span class="hljs-comment">// possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG</span>
        logLevel: config.LOG_INFO,


        <span class="hljs-comment">// enable / disable watching file and executing tests whenever any file changes</span>
        autoWatch: <span class="hljs-literal">true</span>,


        <span class="hljs-comment">// start these browsers</span>
        <span class="hljs-comment">// available browser launchers: https://npmjs.org/browse/keyword/karma-launcher</span>
        browsers: [<span class="hljs-string">'Chrome'</span>],


        <span class="hljs-comment">// Continuous Integration mode</span>
        <span class="hljs-comment">// if true, Karma captures browsers, runs the tests and exits</span>
        singleRun: <span class="hljs-literal">false</span>
    });
};
</span></code>
          </pre>

          <p>Note that most values in the karma.conf file can be overridden at the command line. For example, if you wanted to run Firefox instead of Chrome you could either change the value in karma.conf or keep the value the same and use this command:</p>

          <pre>            <code lang="js" class="hljs sql">karma <span class="hljs-operator"><span class="hljs-keyword">start</span> <span class="hljs-comment">--browsers Firefox</span></span></code>
          </pre>

          <p>I strongly suggest you take an existing karma.conf file like this one and adapt it to meet your needs. As long as you follow the conventions we outline in this guide, the only things you will likely want to change are:</p>

          <ul>
            <li>files - to include all your custom code, dependencies and test code</li>
            <li>reporters - if you want test coverage you will need to include the 'coverage' reporter</li>
            <li>autoWatch and singleRun - most of the time you will want autoWatch=true and singleRun=false so that Karma will automatically re-run your tests as you make changes. However, if you are running Karma as part of a script like a git hook or continuous
              integration, then you will want to flip these two boolean values so that Karma only runs the tests once.</li>
          </ul>

          <h3 class="section-heading" id="basic-jasmine">Basic Jasmine Spec Structure</h3>
          <p class="section-question">How is a basic spec organized?</p>

          <p>
            <em>File Structure</em>
          </p>

          <p>In general, you want to have one test file for each and every non-test code file in your app. You should have a common naming scheme so that your build tools and test runners can pick out test files from non-test files. We are using one of the
            most common test file naming schemes: "{filename}.spec.js". So if you have a code file called "app.js", the file that contains all the tests for app.js would be called "app.spec.js". You will often see all test files in a separate directory
            from the rest of the code (usually called 'test'), but in the sample code we have put all specs right along side the code they are testing for your convenience.</p>

          <p>
            <em>Spec Code Structure</em>
          </p>
          <p>In general, your spec files should follow this structure:</p>

          <pre>            <!-- ngInclude: 'templates/general-spec.tpl.js' --><code ng-include="&#39;templates/general-spec.tpl.js&#39;" class="js ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-comment">// src/app/app.spec.js</span>
<span class="hljs-comment">// Containing describe block (or "suite"), usually named for an app feature.</span>
<span class="hljs-comment">// In this case the feature is the App itself.</span>
describe(<span class="hljs-string">'Unit: App'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    <span class="hljs-comment">// Include Modules</span>
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.about'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.experiments'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.home'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.models.messages'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'ui.router'</span>));

    <span class="hljs-comment">// Suite for testing an individual piece of our feature.</span>
    describe(<span class="hljs-string">'App Abstract Route'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

        <span class="hljs-comment">// Instantiate global variables (global to all tests in this describe block).</span>
        <span class="hljs-keyword">var</span> $state,
            $rootScope,
            state = <span class="hljs-string">'app'</span>;

        <span class="hljs-comment">// Inject dependencies</span>
        beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_$state_, $templateCache, _$rootScope_)</span> </span>{
            $state = _$state_;
            $rootScope = _$rootScope_;
            $templateCache.put(<span class="hljs-string">'app/home/home.tmpl.html'</span>, <span class="hljs-string">''</span>);
        }));

        <span class="hljs-comment">// It block (or "spec") to test expectations for the</span>
        <span class="hljs-comment">// Expectations return true or false.</span>
        it(<span class="hljs-string">'verifies state configuration'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> config = $state.get(state);
            expect(config.abstract).toBeTruthy();
            expect(config.url).toBeUndefined();
        });
    });
});</span></code>
          </pre>

          <p>Two things to note from this example.</p>

          <p>First, you should make liberal use of before, beforeEach, after and afterEach to set up and tear down the appropriate context for tests. Ideally you only have a couple lines of code within each
            <strong>it()</strong> function.</p>

          <p>The second thing to note is that the first parameter for the
            <strong>describe()</strong> and
            <strong>it()</strong> functions may be used by the test runner when tests are executed. For example, when this spec is run, some test runners may output:</p>

          <pre>            <code class="hljs http"><span class="hljs-attribute">Unit</span>: <span class="hljs-string">App App Abstract Route verifies state configuration</span></code>
          </pre>

          <p>So, make sure the string values are descriptive.</p>

          <h3 class="section-heading" id="including-module">Including a Module</h3>
          <p class="section-question">How do I inject a module in a spec?</p>

          <p>The first thing your spec should do is define all the Angular modules that are needed for the tests in that spec. This is done using the
            <strong>module()</strong> function that comes from the
            <strong>angular-mocks</strong> library. For example:

            </p><pre>              <code lang="js" class="hljs coffeescript">beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp'</span>));</code>
            </pre>

            <p>This code will enable the spec to test the code from the
              <strong>myApp</strong> module. It is best practice to use
              <strong>beforeEach()</strong> instead of just
              <strong>before()</strong> so that each test is essentially running from a blank slate. If you don't do this, the state from a previous test may bleed into another test and affect the results.</p>

            <h3 class="section-heading" id="testing-controller">Testing a Controller</h3>
            <p class="section-question">How do I instantiate a controller in a spec?</p>

            <p>Here is our controller that we want to test:</p>

            <pre>              <!-- ngInclude: 'templates/controller-spec.tpl.js' --><code ng-include="&#39;templates/controller-spec.tpl.js&#39;" lang="js" class="ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-comment">// src/app/about/about.js</span>
.controller(<span class="hljs-string">'AboutCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Messages)</span> </span>{
    <span class="hljs-keyword">var</span> about = <span class="hljs-keyword">this</span>;
    about.title = <span class="hljs-string">'About Page'</span>;
    about.body = <span class="hljs-string">'This is the about page body'</span>;

    about.message = Messages.getMessage();

    about.updateMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(m)</span> </span>{
        Messages.setMessage(m);
    };
})</span></code>
            </pre>

            <p>The
              <strong>angular-mocks</strong> library provides a service called
              <strong>$controller</strong> that we can use to help us test our controllers. In the
              <strong>beforeEach()</strong> below, we are injecting
              <strong>$controller</strong> along with any other dependencies we need to instantiate our controller.</p>

            <pre>              <!-- ngInclude: 'templates/advanced-controller.tpl.js' --><code ng-include="&#39;templates/advanced-controller.tpl.js&#39;" lang="js" class="ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-comment">// src/app/about/about.spec.js</span>
describe(<span class="hljs-string">'Unit: About'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

    <span class="hljs-comment">// Define global references for injections.</span>
    <span class="hljs-keyword">var</span> ctrl, messages;

    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.about'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'myApp.models.messages'</span>));
    beforeEach(<span class="hljs-built_in">module</span>(<span class="hljs-string">'ui.router'</span>));

    beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">($controller, _Messages_)</span> </span>{
        messages = _Messages_;

        spyOn(messages, <span class="hljs-string">'setMessage'</span>);
        spyOn(messages, <span class="hljs-string">'getMessage'</span>).and.returnValue(<span class="hljs-string">'Hello!'</span>);

        <span class="hljs-comment">// Instantiate the controller with an object of the dependencies</span>
        ctrl = $controller(<span class="hljs-string">'AboutCtrl'</span>, {
            Messages: messages
        });
    }));

    describe(<span class="hljs-string">'AboutCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Test some basic expectations about the controller</span>
        it(<span class="hljs-string">'should have title defined'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            expect(ctrl.title).toBeDefined();
        });

        it(<span class="hljs-string">'should have body defined'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            expect(ctrl.body).toBeDefined();
        });

        it(<span class="hljs-string">'should call Messages.getMessage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            expect(messages.getMessage).toHaveBeenCalled();

            expect(ctrl.message).toEqual(<span class="hljs-string">'Hello!'</span>);
        });

        it(<span class="hljs-string">'should call updateMessage on message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Hello Message'</span>;

            ctrl.updateMessage(message);

            expect(messages.setMessage).toHaveBeenCalledWith(message);
        });
    });
});</span></code>
            </pre>

            <p>Note that we are using the underscore syntax with
              <strong>_Messages_</strong> to get a global reference to the
              <strong>Messages</strong> service. The underscores are ignored by the injector when the reference name is resolved.</p>

            <p><a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject" target="_blank">https://docs.angularjs.org/api/ngMock/function/angular.mock.inject</a></p>

            <h3 class="section-heading" id="including-service">Including a Service</h3>
            <p class="section-question">How do I inject a service in a spec?</p>

            <p>Testing an Angular service is a piece of cake. You can use the
              <strong>inject()</strong> function from angular-mocks to get a reference to either internal Angular core objects or any of your custom objects in the modules that are defined at the top of the spec. For example:</p>

            <pre>              <!-- ngInclude: 'templates/include-service.tpl.js' --><code ng-include="&#39;templates/include-service.tpl.js&#39;" lang="js" class="ng-scope hljs bash"><span class="ng-scope">beforeEach(inject(<span class="hljs-keyword">function</span>(someService, someFactory) {

    <span class="hljs-built_in">local</span>SomeService = someService;

    <span class="hljs-built_in">local</span>SomeFactory = someFactory;

}));</span></code>
            </pre>

            <p>As a best practice, we suggest injecting objects in
              <strong>beforeEach()</strong> and saving the object to a local variable. Then in the test we just reference that local variable.</p>

            <h3 class="section-heading" id="testing-template">Testing a Template</h3>
            <p class="section-question">How do I test if an element is in the DOM?</p>

            <p>The most tricky thing to test with Angular is code within templates. That is why you should try to reduce the amount of code in your templates as much as possible. Even if you are really good about this, though, you will always have some template
              code that you want to test.</p>

            <p>You can split template testing into two categories. The first category includes templates that don't have any controllers, includes or custom directives. Essentially you are just testing logic that uses basic Angular expressions and core Angular
              directives. This use case is relatively easy to test. Take the following example:</p>


            <pre>              <!-- ngInclude: 'templates/testing-template.tpl.html' --><code ng-include="&#39;templates/testing-template.tpl.html&#39;" lang="html" class="ng-scope hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>{{home.title}}<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{home.body}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">hr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">h2</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"text-error"</span>&gt;</span>Home: {{home.message}}<span class="hljs-tag">&lt;/<span class="hljs-title">h2</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">form</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"form-inline"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"form-control"</span> <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"Message"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"btn btn-default"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"submit"</span>&gt;</span>Update Message<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code>
            </pre>



            <p>We want to have access to this HTML file in our tests, but it is generally a bad idea to make an http call within your tests if you can avoid it. Fortunately, there is a nice feature in Karma that allows us to automatically package all of
              our HTML template files into an Angular module that we can access easily in our tests. Just add the following to your
              <strong>karma.conf.js</strong> file:</p>

            <pre>              <!-- ngInclude: 'templates/nghtml2js.tpl.js' --><code ng-include="&#39;templates/nghtml2js.tpl.js&#39;" lang="js" class="ng-scope hljs sql"><span class="ng-scope">// karma.conf.js
ngHtml2JsPreprocessor: {
    stripPrefix: 'src/',
        // stripSufix: '.ext',

        // setting this option will <span class="hljs-operator"><span class="hljs-keyword">create</span> <span class="hljs-keyword">only</span> a single <span class="hljs-keyword">module</span> that contains templates
        // <span class="hljs-keyword">from</span> <span class="hljs-keyword">all</span> the files, so you can <span class="hljs-keyword">load</span> them <span class="hljs-keyword">all</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">module</span>(<span class="hljs-string">'foo'</span>)
        moduleName: <span class="hljs-string">'myAppTemplates'</span>
}</span></span></code>
            </pre>

            <p>This will automatically package any file ending in .html within your src/ folder into an Angular module called myAppTemplates. Each template is accessible by using the
              <strong>$templateCache</strong> service. You can can test this template simply by injecting the
              <strong>$compile</strong> service with some test data and then checking the resulting HTML:</p>

            <pre>              <!-- ngInclude: 'templates/use-nghtml2js.tpl.js' --><code ng-include="&#39;templates/use-nghtml2js.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope">describe(<span class="hljs-string">'UNIT test myTemplates'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    beforeEach(module(<span class="hljs-string">'myAppTemplates'</span>));
    describe(<span class="hljs-string">'home template'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> homeTemplate,
            compile;

        beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$templateCache</span>, <span class="hljs-variable">$compile</span>)</span> </span>{
            homeTemplate = <span class="hljs-variable">$templateCache</span>.get(<span class="hljs-string">'app/home/home.tmpl.html'</span>);
            compile = <span class="hljs-variable">$compile</span>;
        }));

        it(<span class="hljs-string">'should have an h1 with my title'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> testScope = {
                home: {
                    title: <span class="hljs-string">'blah'</span>
                }
            };

            <span class="hljs-keyword">var</span> element = compile(homeTemplate)(testScope);
            expect(element.find(<span class="hljs-string">'h1'</span>).text()).toBe(<span class="hljs-string">'blah'</span>);
        });
    });
});</span></code>
            </pre>

            <p>The second category of template testing is unfortunately more complex. We need to deal with dependencies within the template or surrounding the template such as a controller, the UI router, directives, etc. Let's look at one example of a more
              complex use case that includes a UI Router state and a controller:</p>

            <pre>              <!-- ngInclude: 'templates/complex-templates.tpl.js' --><code ng-include="&#39;templates/complex-templates.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/home/home.js</span>
.config(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$stateProvider</span>)</span> </span>{
    <span class="hljs-variable">$stateProvider</span>
        .state(<span class="hljs-string">'about'</span>, {
            url: <span class="hljs-string">'/about'</span>,
            templateUrl: <span class="hljs-string">'app/about/about.tmpl.html'</span>,
            controller: <span class="hljs-string">'AboutCtrl as about'</span>
        })
    ;
})
.controller(<span class="hljs-string">'AboutCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Messages)</span> </span>{
    <span class="hljs-keyword">var</span> about = this;
    about.title = <span class="hljs-string">'About Page'</span>;
    about.body = <span class="hljs-string">'This is the about page body'</span>;

    about.message = Messages.getMessage();

    about.updateMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(m)</span> </span>{
        Messages.setMessage(m);
    };
})</span></code>
            </pre>

            <p>In order to test the template and associated controller code, we need to instantiate the controller and surrounding context. To that end, we have created a helper function called
              <strong>compileRouteTemplateWithController</strong> that does everything we need.</p>

            <pre>              <!-- ngInclude: 'templates/big-function.tpl.js' --><code ng-include="&#39;templates/big-function.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileRouteTemplateWithController</span><span class="hljs-params">(<span class="hljs-variable">$injector</span>, state)</span> </span>{
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$rootScope</span> = <span class="hljs-variable">$injector</span>.get(<span class="hljs-string">'$rootScope'</span>);
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$templateCache</span> = <span class="hljs-variable">$injector</span>.get(<span class="hljs-string">'$templateCache'</span>);
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$compile</span> = <span class="hljs-variable">$injector</span>.get(<span class="hljs-string">'$compile'</span>);
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$state</span> = <span class="hljs-variable">$injector</span>.get(<span class="hljs-string">'$state'</span>);
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$controller</span> = <span class="hljs-variable">$injector</span>.get(<span class="hljs-string">'$controller'</span>);

    <span class="hljs-keyword">var</span> scope = <span class="hljs-variable">$rootScope</span>.<span class="hljs-variable">$new</span>();
    <span class="hljs-keyword">var</span> stateDetails = <span class="hljs-variable">$state</span>.get(state);
    <span class="hljs-keyword">var</span> html = <span class="hljs-variable">$templateCache</span>.get(stateDetails.templateUrl);

    <span class="hljs-keyword">var</span> ctrl = scope.home = <span class="hljs-variable">$controller</span>(<span class="hljs-string">'HomeCtrl'</span>);
    <span class="hljs-variable">$rootScope</span>.<span class="hljs-variable">$digest</span>();
    <span class="hljs-keyword">var</span> compileFn = <span class="hljs-variable">$compile</span>(angular.element(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>).html(html));

    <span class="hljs-keyword">return</span> {
        controller: ctrl,
        scope: scope,
        render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> element = compileFn(scope);
            <span class="hljs-variable">$rootScope</span>.<span class="hljs-variable">$digest</span>();
            <span class="hljs-keyword">return</span> element;
        }
    };
}</span></code>
            </pre>

            <p>We are using this helper function to get all the dependencies we need to run our tests. This includes creating scope, a controller and a render function. Feel free to use this and adapt it to your needs. Also, as an aside, whenever you see
              a lot of repetitive code within your tests, make sure you create your own helper functions.</p>

            <p>OK, now we have everything in place to test our template.</p>

            <pre>              <!-- ngInclude: 'templates/helper-code.tpl.js' --><code ng-include="&#39;templates/helper-code.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope">describe(<span class="hljs-string">'home page'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Define global references for injections.</span>
    <span class="hljs-keyword">var</span> element, render, ctrl, scope;

    beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$injector</span>)</span> </span>{
        <span class="hljs-comment">// Call the helper function that "creates" a page.</span>
        <span class="hljs-comment">// This just creates references to the attributes</span>
        <span class="hljs-comment">// on the returned object for use in this suite.</span>
        <span class="hljs-keyword">var</span> routeDetails = compileRouteTemplateWithController(<span class="hljs-variable">$injector</span>, <span class="hljs-string">'home'</span>);
        ctrl = routeDetails.controller;
        scope = routeDetails.scope;

        render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            element = routeDetails.render();
        };
    }));

    <span class="hljs-comment">// Test your expectations. You can use ordinary jQuery methods</span>
    it(<span class="hljs-string">'should render the page title'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        scope.home.title = <span class="hljs-string">'Hello'</span>;
        render();
        expect(element.find(<span class="hljs-string">'h1'</span>).text()).toBe(<span class="hljs-string">'Hello'</span>);
    });

    it(<span class="hljs-string">'should have body defined'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        scope.home.body = <span class="hljs-string">'body...'</span>;
        render();
        expect(element.find(<span class="hljs-string">'p'</span>).text()).toBe(<span class="hljs-string">'body...'</span>);
    });

    it(<span class="hljs-string">'should call Messages.getMessage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        render();
        expect(Messages.getMessage).toHaveBeenCalled();

        ctrl.updateMessage(<span class="hljs-string">'yo!'</span>);
        expect(Messages.setMessage).toHaveBeenCalled();
    });

    it(<span class="hljs-string">'should call Messages.setMessage when submit is clicked'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        render();
        element.find(<span class="hljs-string">'input'</span>).val(<span class="hljs-string">'Lukas'</span>);
        element.find(<span class="hljs-string">'input'</span>).triggerHandler(<span class="hljs-string">'input'</span>);
        scope.<span class="hljs-variable">$digest</span>();

        element.find(<span class="hljs-string">'button'</span>).triggerHandler(<span class="hljs-string">'click'</span>);
        scope.<span class="hljs-variable">$digest</span>();

        expect(Messages.getMessage).toHaveBeenCalled();
        expect(scope.home.message).toEqual(<span class="hljs-string">'Lukas'</span>);
    });

    it(<span class="hljs-string">'should call updateMessage on message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Hello Message'</span>;

        ctrl.updateMessage(message);

        expect(Messages.setMessage).toHaveBeenCalledWith(message);
    });
});</span></code>
            </pre>

            <p>The key part of this test was the use of the helper function to instantiate the template and all required dependencies:</p>

            <pre>              <!-- ngInclude: 'templates/instantiate.tpl.js' --><code ng-include="&#39;templates/instantiate.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-keyword">var</span> routeDetails = compileRouteTemplateWithController(<span class="hljs-variable">$injector</span>, <span class="hljs-string">'home'</span>);
ctrl = routeDetails.controller;
scope = routeDetails.scope;

render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    element = routeDetails.render();
};</span></code>
            </pre>


            <h3 class="section-heading" id="testing-route">Testing a Route</h3>
            <p class="section-question">How do I test route changes?</p>

            <p>Testing a route essentially means testing that we configured the UI router $stateProvider correctly during the config phase. For example, given the following state configuration:</p>

            <pre>              <!-- ngInclude: 'templates/route.tpl.js' --><code ng-include="&#39;templates/route.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/about/about.js</span>
.config(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$stateProvider</span>)</span> </span>{
    <span class="hljs-variable">$stateProvider</span>
        .state(<span class="hljs-string">'about'</span>, {
            url: <span class="hljs-string">'/about'</span>,
            templateUrl: <span class="hljs-string">'app/about/about.tmpl.html'</span>,
            controller: <span class="hljs-string">'AboutCtrl as about'</span>
        })
    ;
})</span></code>
            </pre>

            <p>Our basic strategy for testing is to use the
              <strong>$state.go()</strong> and
              <strong>$state.href()</strong> methods to modify the current state and then check to make sure the route is changed appropriately.</p>

            <pre>              <!-- ngInclude: 'templates/route-test.tpl.js' --><code ng-include="&#39;templates/route-test.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/about/about.spec.js</span>
describe(<span class="hljs-string">'About Route'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Define global references for injections</span>
    <span class="hljs-keyword">var</span> <span class="hljs-variable">$state</span>,
        <span class="hljs-variable">$rootScope</span>,
        state = <span class="hljs-string">'about'</span>;

    <span class="hljs-comment">// Inject and assign the $state and $rootScope services.</span>
    <span class="hljs-comment">// Put the template in template cache.</span>
    beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_<span class="hljs-variable">$state_</span>, <span class="hljs-variable">$templateCache</span>, _<span class="hljs-variable">$rootScope_</span>)</span> </span>{
        <span class="hljs-variable">$state</span> = _<span class="hljs-variable">$state_</span>;
        <span class="hljs-variable">$rootScope</span> = _<span class="hljs-variable">$rootScope_</span>;

        <span class="hljs-variable">$templateCache</span>.put(<span class="hljs-string">'app/about/about.tmpl.html'</span>, <span class="hljs-string">''</span>);
    }));

    <span class="hljs-comment">// Test whether the url is correct</span>
    it(<span class="hljs-string">'should respond to URL'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        expect(<span class="hljs-variable">$state</span>.href(state)).toEqual(<span class="hljs-string">'/about'</span>);
    });

    <span class="hljs-comment">// Test whether our state activates correctly</span>
    it(<span class="hljs-string">'should activate the state'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-variable">$state</span>.go(state);
        <span class="hljs-variable">$rootScope</span>.<span class="hljs-variable">$digest</span>();
        expect(<span class="hljs-variable">$state</span>.current.name).toBe(state);
    });
});</span></code>
            </pre>

            <h3 class="section-heading" id="testing-directive">Testing a Directive</h3>
            <p class="section-question">How do I set up a spec for a directive?</p>

            <p>Similar to how we test a template, we use the $compile service to help us test a directive. The key is to pass in a HTML snippet to
              <strong>$compile()</strong> that refers to the target directive. For example, if you had an element directive called 'experiment', you would simply call
              <strong>$compile("&lt;experiment&gt;&lt;/experiment&gt;")</strong>. You can see the full example here:</p>

            <pre>              <!-- ngInclude: 'templates/directive.tpl.js' --><code ng-include="&#39;templates/directive.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-binding ng-scope"><span class="hljs-comment">// app/experiments/experiments.js</span>
.directive(<span class="hljs-string">'experiment'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">var</span> linker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scope, element, attrs)</span> </span>{
        element.on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
            scope.doExperiment();
        })
    };

    <span class="hljs-keyword">var</span> controller =  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$scope</span>)</span></span>{
        <span class="hljs-variable">$scope</span>.doExperiment = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-variable">$scope</span>.<span class="hljs-variable">$apply</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
                <span class="hljs-variable">$scope</span>.experiment.completed++;
            });
        };
    };

    <span class="hljs-keyword">return</span> {
        scope: <span class="hljs-keyword">true</span>,
        restrict: <span class="hljs-string">'E'</span>,
        template: <span class="hljs-string">'&lt;div class="experiment"&gt;'</span> +
        <span class="hljs-string">'&lt;h3&gt;{{experiment.name}}&lt;/h3&gt;'</span> +
        <span class="hljs-string">'&lt;p&gt;{{experiment.description}}&lt;/p&gt;'</span> +
        <span class="hljs-string">'&lt;p&gt;&lt;strong&gt;{{experiment.completed}}&lt;/strong&gt;&lt;/p&gt;'</span> +
        <span class="hljs-string">'&lt;/div&gt;'</span>,
        link: linker,
        controller: controller
    }
})</span></code>
            </pre>

            And the spec.

            <pre>              <!-- ngInclude: 'templates/directive-test.tpl.js' --><code ng-include="&#39;templates/directive-test.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/experiments/experiments.spec.js</span>
describe(<span class="hljs-string">'Experiments Directive'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Define global references for injections</span>
    <span class="hljs-keyword">var</span> element, experiment;

    beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$rootScope</span>, <span class="hljs-variable">$compile</span>)</span> </span>{
        <span class="hljs-comment">// Mock out an experiment</span>
        <span class="hljs-variable">$rootScope</span>.experiment = {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"Experiment 1"</span>,
            <span class="hljs-string">"description"</span>: <span class="hljs-string">"This is an experiment"</span>,
            <span class="hljs-string">"completed"</span>: <span class="hljs-number">0</span>
        };
        <span class="hljs-comment">// Create an html element with the directive</span>
        element = angular.element(<span class="hljs-string">'&lt;experiment&gt;&lt;/experiement&gt;'</span>);
        <span class="hljs-comment">// Compile the element and $rootScope,</span>
        <span class="hljs-comment">// which essentially instantiates the directive as it would be on a web page.</span>
        <span class="hljs-variable">$compile</span>(element)(<span class="hljs-variable">$rootScope</span>);
    }));

    it(<span class="hljs-string">'should increment experiment completed count'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Get the directive's scope</span>
        <span class="hljs-keyword">var</span> localScope = element.scope();

        <span class="hljs-comment">// Test some expectations about the directive.</span>
        expect(localScope.experiment.completed).toBe(<span class="hljs-number">0</span>);

        localScope.doExperiment();

        expect(localScope.experiment.completed).toBe(<span class="hljs-number">1</span>);
    });
})</span></code>
            </pre>

            <p>Note: depending on what your directive does, you may need to modify the HTML passed into
              <strong>$compile</strong>. For example, if the directive expects other attributes on the element or if you are testing a directive with transclusion (in which case you will want to put different snippets of HTML as children to the element that has
              the directive).</p>

            <h3 class="section-heading" id="mocking">Mocking</h3>
            <p class="section-question">How/Why do I mock a service call in a controller spec?</p>

            <p>We mentioned at the beginning that you can create both unit tests and integration tests with Karma. When you are writing a unit test, your goal is to test just one thing and either eliminate or mock out all other dependencies. In general,
              you can mock any object through the use of the
              <strong>$provide</strong> service. You use this service when you define the module you are using in your spec. For example:

              </p><pre>                <!-- ngInclude: 'templates/mocking.tpl.js' --><code ng-include="&#39;templates/mocking.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope">beforeEach(module(<span class="hljs-string">"app"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$provide</span>)</span> </span>{
    <span class="hljs-variable">$provide</span>.value(<span class="hljs-string">"SimpleService"</span>, {
        someFn: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{}
    });
}));</span></code>
              </pre>

              <p>In this case, we are overriding the SimpleService object. Once we do this, any code that injects SimpleService will get our mock object instead of the actual SimpleService.</p>

              <p>There is one special case with mocking where Angular helps you out. Whenever you use
                <strong>$http</strong> to make a remote call, Angular has another service behind the scenes called
                <strong>$httpBackend</strong> that actually does all the hard work. The angular-mocks library has its own version of
                <strong>$httpBackend</strong> with a number of goodies to help us mock out calls to the back end. For example look at this code which makes an
                <strong>$http</strong> call:</p>

              <pre>                <!-- ngInclude: 'templates/$http-backend.tpl.js' --><code ng-include="&#39;templates/$http-backend.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/experiments/experiments.js</span>
.service(<span class="hljs-string">'Experiments'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$http</span>)</span> </span>{
    <span class="hljs-keyword">var</span> service = this;

    service.getExperiments = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-variable">$http</span>.get(<span class="hljs-string">'data/experiments.json'</span>);
    };
})</span></code>
              </pre>

              <p>If we call
                <strong>getExperiments()</strong> in our test, it will make an actual http request to data/experiments.json. We can intercept that call with
                <strong>$httpBackend</strong>, however, and define what should be returned instead of making a remote call.</p>

              <pre>                <!-- ngInclude: 'templates/$http-backend-example.tpl.js' --><code ng-include="&#39;templates/$http-backend-example.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/experiments/experiments.spec.js</span>
describe(<span class="hljs-string">'Experiments Model'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// After every spec, do the following:</span>
    afterEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$httpBackend</span>)</span> </span>{
        <span class="hljs-comment">// Make sure we have flushed all of our requests.</span>
        <span class="hljs-variable">$httpBackend</span>.verifyNoOutstandingExpectation();
        <span class="hljs-variable">$httpBackend</span>.verifyNoOutstandingRequest();
    }));

    it(<span class="hljs-string">'Should get experiments'</span>, inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Experiments, <span class="hljs-variable">$httpBackend</span>, <span class="hljs-variable">$rootScope</span>)</span> </span>{
        <span class="hljs-keyword">var</span> mockResponse = [];
        <span class="hljs-comment">// Every time we hit the specified url,</span>
        <span class="hljs-comment">// respond with mockResponse( in this case an empty array).</span>
        <span class="hljs-variable">$httpBackend</span>.when(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'data/experiments.json'</span>).respond(mockResponse);

        <span class="hljs-comment">// The promise reference now holds the $http call returned</span>
        <span class="hljs-keyword">var</span> promise = Experiments.getExperiments();
        <span class="hljs-comment">// Flush the backend</span>
        <span class="hljs-variable">$httpBackend</span>.flush();

        <span class="hljs-comment">// Use .then() like you would normally.</span>
        promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(result)</span> </span>{
            expect(result.data).toEqual(mockResponse);
        });

        <span class="hljs-comment">// Manually trigger a $digest cycle</span>
        <span class="hljs-variable">$rootScope</span>.<span class="hljs-variable">$digest</span>();
    }));
});</span></code>
              </pre>

              <p>Note that
                <strong>$httpBackend.flush()</strong> is needed because normally $http is asynchronous, but we want to execute our test in a synchronous fashion. The call to
                <strong>flush()</strong> will ensure that the
                <strong>.then()</strong> on the promise returned from $http will be executed immediately.</p>

              <h3 class="section-heading" id="spying-methods">Spying on Methods</h3>
              <p class="section-question">How do I determine if one method successfully calls another method?
                <br> How do I determine what arguments were included when I call a method?</p>

              <p>Jasmine uses a spy to determine whether a method has been called and/or what arguments are set into a method call. So, for example:</p>

              <pre>                <!-- ngInclude: 'templates/spying.tpl.js' --><code ng-include="&#39;templates/spying.tpl.js&#39;" lang="js" class="ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-keyword">var</span> foo, bar = <span class="hljs-literal">null</span>;

beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Here we create a simple object foo with a method setBar, which takes one argument.</span>
    foo = {
        setBar: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
            bar = value;
        }
    }
};

<span class="hljs-comment">// Now whenever foo.setBar is called in this spec or in the source code,</span>
<span class="hljs-comment">// we can perform assertions on it.</span>
spyOn(foo, <span class="hljs-string">'setBar'</span>);

foo.setBar(<span class="hljs-number">123</span>);

it(<span class="hljs-string">"tracks that the spy was called"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(foo.setBar).toHaveBeenCalled();
});

it(<span class="hljs-string">"tracks the arguments of its calls"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    expect(foo.setBar).toHaveBeenCalledWith(<span class="hljs-number">123</span>);
});</span></code>
              </pre>


              <p>A spy only exists within the
                <strong>describe()</strong> or
                <strong>it()</strong> function where it has been defined.</p>

              <h3 class="section-heading bottom-margin" id="advanced-spying">Advanced Spying</h3>

              <p>In addition to simply seeing if a spy has been called, we can also define what value the spy should return (using returnValue()) or what fake function the spy should run instead of the target function (using callFake()). For example:</p>

              <pre>                <!-- ngInclude: 'templates/advanced-spying.tpl.js' --><code ng-include="&#39;templates/advanced-spying.tpl.js&#39;" lang="js" class="ng-scope hljs javascript"><span class="ng-scope"><span class="hljs-comment">// app/experiments/experiments.js</span>
.controller(<span class="hljs-string">'ExperimentsCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Messages, Experiments)</span> </span>{
    <span class="hljs-keyword">var</span> experiments = <span class="hljs-keyword">this</span>;
    experiments.title = <span class="hljs-string">'Experiments Page'</span>;
    experiments.body = <span class="hljs-string">'This is the about experiments body'</span>;

    experiments.message = Messages.getMessage();

    Experiments.getExperiments()
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span></span>{
            experiments.experiments = result.data;
        });

    experiments.updateMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(m)</span> </span>{
        Messages.setMessage(m);
    };
})</span></code>
              </pre>

              And the spec.

              <pre>                <!-- ngInclude: 'templates/advanced-spying-test.tpl.js' --><code ng-include="&#39;templates/advanced-spying-test.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope"><span class="hljs-comment">// app/experiments/experiments.spec.js</span>
describe(<span class="hljs-string">'ExperimentsCtrl'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Inject and assign services and create the controller.</span>
    beforeEach(inject(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$controller</span>, _Messages_, _Experiments_, <span class="hljs-variable">$q</span>)</span> </span>{
        messages = _Messages_;
        experiments = _Experiments_;

        <span class="hljs-comment">// Here we create a spy just like before,</span>
        <span class="hljs-comment">// but now it is spying on a method attached to a service.</span>
        spyOn(messages, <span class="hljs-string">'setMessage'</span>);
        <span class="hljs-comment">// Every time Messages.getMessage is called,</span>
        <span class="hljs-comment">// we want the value 'Hello!' to be returned.</span>
        spyOn(messages, <span class="hljs-string">'getMessage'</span>).<span class="hljs-keyword">and</span>.returnValue(<span class="hljs-string">'Hello!'</span>);

        <span class="hljs-comment">// Every time Messages.getExperiments is called,</span>
        <span class="hljs-comment">// we execute the function contained within the callFake method.</span>
        spyOn(experiments, <span class="hljs-string">'getExperiments'</span>).<span class="hljs-keyword">and</span>.callFake(
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-comment">// Since we don't want to deal with an $http call</span>
                <span class="hljs-comment">// in the controller, we mock it out using $q.</span>
                <span class="hljs-keyword">var</span> deferred = <span class="hljs-variable">$q</span>.defer();
                deferred.resolve({data: []});
                <span class="hljs-keyword">return</span> deferred.promise;
            }
        );

        ctrl = <span class="hljs-variable">$controller</span>(<span class="hljs-string">'ExperimentsCtrl'</span>, {
            Messages: messages,
            Experiments: experiments
        });
    }));

    <span class="hljs-comment">// Now we can see if the methods we are spying on actually execute;</span>
    <span class="hljs-comment">// also, we can test some expectations on the portions of the controller</span>
    <span class="hljs-comment">// that interact with our spies.</span>
    it(<span class="hljs-string">'should call Messages.getMessage'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        expect(messages.getMessage).toHaveBeenCalled();

        expect(ctrl.message).toEqual(<span class="hljs-string">'Hello!'</span>);
    });

    it(<span class="hljs-string">'should call updateMessage on message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> message = <span class="hljs-string">'Hello Message'</span>;

        ctrl.updateMessage(message);

        expect(messages.setMessage).toHaveBeenCalledWith(message);
    });
});</span></code>
              </pre>

              <h3 class="section-heading" id="testing-promise">Testing a Promise</h3>
              <p class="section-question">How do I handle async operations in a spec?</p>

              <p>By default, each test runs synchronously. So, if you have any asynchronous operation, the test will complete before the operation completes. There are ways of handling specific use cases (for example
                <strong>$httpBackend.flush()</strong> as mentioned earlier), but you can also use the Jasmine
                <strong>done()</strong> function. For example:</p>

              <pre>                <!-- ngInclude: 'templates/promise.tpl.js' --><code ng-include="&#39;templates/promise.tpl.js&#39;" lang="js" class="ng-scope hljs php"><span class="ng-scope">it(<span class="hljs-string">'should do something'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> </span>{
    someAsyncOperation
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            done();
        })
        .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
            done(err);
        });
});</span></code>
              </pre>

              <p>In this example, the test will not complete until
                <strong>done()</strong> is called. If
                <strong>done()</strong> contains a parameter, Jasmine treats that as an error and fails the test.</p>

              <p>One last note on async operations. You may have noticed in our examples a call to
                <strong>$rootScope.$digest()</strong>. This will force the digest cycle to run which is needed whenever we are testing anything athat involves watchers (so, anything with templates).</p>

              <h3 class="section-heading" id="debugging">Debugging</h3>
              <p class="section-question">How do I troubleshoot problems with my specs?</p>

              <p>Spec code is run in the browser just like any other client side code. So, how do you debug your Angular app? That's right, the Chrome/FireFox dev tools. For example, after running Karma with Chrome there should be a Chrome window open on
                your machine that contains the output of the test. To debug, simply open up the Chrome dev tools and refresh the page.</p>

              <h3 class="section-heading" id="best-practices">Best Practices</h3>
              <p class="section-question">How do I know I am formatting my specs in the most efficient manner?</p>

              <p>Here is a quick list of best practices. Some of these we touched on earlier.</p>
              <ul>
                <li>Use
                  <strong>beforeEach()</strong> to set up the context for your tests.</li>
                <li>Make sure the string descriptions you put in
                  <strong>describe()</strong> and
                  <strong>it()</strong> make sense as output</li>
                <li>Use
                  <strong>after()</strong> and
                  <strong>afterEach()</strong> to cleanup your tests if there is any state that may bleed over.</li>
                <li>If any one test is over 10 lines of code, you may need to refactor the test</li>
                <li>If you find yourself repeating the same code for many tests, refactor the common code into a helper function</li>
              </ul>

              <h3 class="section-heading" id="resources">Resources</h3>

              <p class="section-question"></p>

              <p>If you want to do some more digging, here are 6 resources that will get you started.</p>
              <ul>
                  <li>
                      <a target="_blank" href="https://docs.angularjs.org/guide/unit-testing">Angular Unit Testing Docs</a>
                  </li>
                  <li>
                      <a target="_blank" href="http://karma-runner.github.io/0.13/index.html">Karma Docs</a>
                  </li>
                  <li>
                      <a target="_blank" href="http://jasmine.github.io/2.0/introduction.html">Jasmine Docs</a>
                  </li>
                  <li>
                      <a target="_blank" href="https://www.airpair.com/angularjs/posts/unit-testing-angularjs-applications">Unit testing Angular applications</a>
                  </li>
                  <li>
                      <a target="_blank" href="http://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/">Unit Testing in Angular: Services, Controllers &amp; Providers</a>
                  </li>
                  <li>
                      <a target="_blank" href="http://www.sitepoint.com/mocking-dependencies-angularjs-tests/">Mocking Dependencies in Angular Tests</a>
                  </li>
              </ul>
        </div>
      </div>
    </div>
  </div>

  <div id="toTop" style="display: block;">
    <a href="http://angulartestingquickstart.com/#top">
      <span class="glyphicon glyphicon-arrow-up"></span>
    </a>
  </div>

  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="./Angular Unit Testing_files/jquery.min.js"></script>
  <!-- Latest compiled and minified JavaScript -->
  <script src="./Angular Unit Testing_files/bootstrap.min.js"></script>
  <script src="./Angular Unit Testing_files/highlight.min.js"></script>
  <script src="./Angular Unit Testing_files/angular.min.js"></script>
  <script>
//    hljs.initHighlightingOnLoad();
/*$('code').each(function(i, block) {
  hljs.highlightBlock(block);
});*/
  </script>
  <script>
    var app = angular.module('Quickstart', []);

    app.config(function ($locationProvider) {
      $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
      });
    })

    app.directive('code', function ($timeout) {
      return {
        restrict: 'E',
        link: function (scope, element, attrs) {
          hljs.highlightBlock(element[0])

          if (attrs.lang == 'html') {
            element.html(element.find('script').html());

          }
        }
      }
    })
  </script>
  <script>
    var innerHeight = $(window).innerHeight();

    $(window).scroll(function() {
      innerHeight = $(window).innerHeight();
      $('#table-of-contents').css('max-height', innerHeight);

      if ($(this).scrollTop()) {
        $('#toTop:hidden').stop(true, true).fadeIn();
      } else {
        $('#toTop').stop(true, true).fadeOut();
      }
    });

    $('#table-of-contents').css('max-height', innerHeight);
  </script>




</body></html>